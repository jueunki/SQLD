식별자 : 각각의 인스턴스를 구분 가능하게 만들어주는 대표 격인 속성을 의미

** 주식별자 : 기본키, PK(Primarykey)/하나의 속성이 주식별자가 될 수도있고 여러개의 속성이 주식별자가 될 수도있다.

* 유일성 : 각 모든 인스턴스에 유니크함을 부여해 식별가능하도록함
* 최소성 : 유일성을 보장하는 최소 개수의 속성이어야함
* 불변성 : 속성값이 되도록 변하지 않아야함
* 존재성 : 속성값이 NULL일수없음/속성값이 존재해야함

-------

식별자를 분류하는 방식은 :
*대표성 여부			: 주식별자/보조식별자
*스스로 생성되었는지 여부	: 내부식별자/외부식별자
*단일속성의 여부		: 단일식별자/복합식별자
*대체여부			: 원조식별자/대리식별자
이 네가지로 나뉜다.

주 :	유일,최소,불변,존재성을 가진 대표식별자/다른엔터티와 참조관계로 연결 
보조 : 	대표식별자가 아니지만 인스턴스를 식별가능/다른엔터이와 참조관계로 연결되어있지않음

내부 : 엔터티 내부에서 스스로 생성된 식별자
외부 : 다른엔터티에서 온 식별자,다른엔터티와의 연결고리 약함

단일 : 하나의 속성으로 구성된 식별자
복합 : 두개 이상의 속성으로 구성된 식별자

원조 : 업무 프로세스에 존재하는 식별자, 가공되지않은 원래의 식별자(본질식별자)
대리 : 주식별자의 속성이 두 개 이상인 경우 그 속성들을 하나로 묶어서 사용하는 식별자(인조식별자)

-------

 		식별자 관계 			VS 		비식별자 관계
강한관계							약한관계
부모 엔터티의 식별자가 자식 엔터티의 주식별자		부모 엔터티의 식별자가 자식 엔터티의 일반속성
부모 엔터티가 있어야 생성 가능				부모 엔터티 없는 자식 엔터티 생성 가능
실선으로 표현							점선으로 표현

* 식별자 관계 : 부모가 자식의 주식별자가 되는관계/부모엔터티가 있어야 주식별자 생성가능/단일인지 복합인지에 따라 1:1 이거나 1:M이거나가 결정됨

* 비식별자 관계 : 부모가 자식의 주가 아닌 일반속성이 되는관계/일반속성은 NULL이 될 수 있으므로 부모가 없는 자식생성이 가능하고 자식이 존재하는 상태에서 부모엔터티가 삭제될수있다.


문제 나올 때 M:1이라고 나올 수 있는데 잘 읽어보고 문제 풀것!

-------

문제로 총 정리***

* 데이터 모델링
	데이터의 정의를 데이터의 사용 프로세스와 분리함으로 프로세스의 변화로 인해 데이터 모델이 수시로 변경될 가능성을 줄인다
	데이터 간의 일관성을 유지하기 위해 상호 연관 관계를 명확하게 정의해야한다.
	같은 데이터가 여러군데 중복되어 저장되지 않도록 한다.
	어플리케이션과 데이터간의 연계성이 높으면 어플리케이션이 변경될 때마다 데이터 모델도 변경되어야하는 상황이 생길수 있다.->비유연성을 가지게돈다
-데이터 모델링을 할 때 지양해야 할 점 : 중복/비유연성/비일관성

---
차이를 기억해둘것

* 발생시점에 따른 엔터티의 분류 : 기본 엔터티, 중심 엔터티, 행위 엔터티

* 유,무형에 따른 엔터티의 분류 : 유형 엔터티, 개념 엔터티, 사건 엔터티

---
* ERD에 대한 설명
	관계명으로 엔터티 간의 관계를 알 수 있다.
	1:1의 관계 차수를 갖는 엔터티들은 관계에 참여하는 각각의 엔터티에 대해 단지 하나의 관계만을 가지고있다.
	관계 차수로는 1:1, 1:M, M:N이 있을 수 있다.
	존재에 의한 관계와 행위에 의한 관계를 구분하지 않고 표현하며 클래스 다이어그램에서는 이것을 구분하여 연관 관계와 의존관계로 표현한다.	

---
* 비일관성 : 데이터의 중복이 없는 경우에도 발생할 수 있다. 개발자가 다른 데이터와의 연관성을 고려하지 않고 일부 데이터만 변경할 수 있기 때문이다.
	     이런 위험을 예방하기 위해 데이터 모델링을 할 때 데이터 간의 연관 관계에 대해 명확하게 정의해야한다.

* 중복 : 같은 데이터가 여러 엔터티에 중복으로 저장되는 현상을 지양해야 한다.

* 비유연성 : 데이터 모델의 설계에 따라 어플리케이션의 사소한 변경에도 데이터 모델이 수시로 변경이 되어야 하는 상황이 생길 수 있다.
	     이런 상황은 시스템을 유지보수하는 데에 어려움을 가중시키므로 데이터 모델과 프로세스를 분리하여 유연성을 높이는 것이 바람직하다.

---
ERD 작성 순서 :
	
	엔터티를 그린다
	엔터티를 적절하게 배치한다
	엔터티 간의 관계를 나타낸다
	관계명을 정의한다
	관계의 참여도를 나타낸다
	관계의 필수 여부를 나타낸다

---
IE/Crow's Foot (까마귀 발) 표기법 : 실선에 딱 봐도 까마귀발처럼 생겼다.

	까마귀 발 기호는 2개 이상을 의미한다
	엔터티는 사각형으로 표기한다
	해시 마크는 1개를 의미한다
	점선은 비식별자 관계를 의미한다

---
기본 엔터티 : 업무에 원래 존재하는 정보/독립적으로 생성/자식엔터티를 가질수있음
ex. 상품,회원,사원,부서
중심 엔터티 : 기본 엔터티로부터 파생/행위 엔터티 생성/업무에 있어서 중심적역할/데이터의 양이많이 발생함
ex. 주문,매출,계약
행위 엔터티 : 2개 이상의 엔터티로부터 파생/데이터가 자주 변경되거나 증가할 수 있음
ex. 주문내역, 이벤트응모이력

---
속성 :의미상 분리되지 않는 최소의 데이터 레벨/프로세스에 필요한 항목이어야한다.

---

	관계명 		: 관계의 이름을 나타냄
	관계차수	: 1:1, 1:M, M:N과 같은 관계의 기수성을 나타냄
	관계선택사양	: 관계가 필수 관계인지, 선택 관계인지를 나타냄
	
---
엔터티 간의 관계에서 부모-자식의 관계 외에 다른 관계도 존재할 수 있다.
두 엔터티 사이를 이어주는 동사가 존재해야한다
사이에 조합되는 정보가 존재해야한다
사이에 영향력 있는 관계가 존재해야한다

---
보조 식별자 : 인스턴스를 식별할 수 있지만 대표 식별자가 아닌 식별자로 다른 엔터티와 참조관계로 연결되지 않는다. 

---
복합 식별자 : 두 개 이상의 속성으로 구성된 식별자
보조 식별자 : 인스턴스를 식별할 수는 있지만 대표 식별자가 아님/다른 엔터티와 참조관계로 연결되지않음
외부 식별자 : 다른 엔터티에서 온 식별자/다른 엔터티와의 연결고리 역할
대리 식별자(인조 식별자) : 주식별자의 속성이 두 개 이상인 경우 그 속성들을 하나로 묶어서 사용하는 식별자

-------
* 정규화 : 데이터의 정확성과 일관성을 유지/보장 하기위해 엔터티를 작은 단위로 분리하는 과정
	   데이터 조회 성능은 처리조건에 따라 향상되는 경우도 있고 저하되는 경우로 있지만
	   입력,수정,삭제 성능은 일반적으로 향상되지만 엔터티가 계속 증가함으로 JOIN으로 인한 조회성능 저하가 발생할수있다.
	   무작정 분류하면 안되기 때문에 일정한 룰이 존재한다.//제1정규형, 제2정규형, 제3정규형

데이터에 대한 중복성을 제거한다
정규화 할수록 엔터티는 증가한다
데이터 입력, 수정, 삭제 성능이 향상된다
엔터티가 증가하므로 JOIN으로 인한 조회성능저하가 발생할수있다

* 제1정규형
모든 속성은 하나의 값만 가져야 한다

* 제2정규형
모든 일반속성은 모든 주식별자에 종속되어야한다
주식별자가 단일식별자가 아닌 복합식별자인 경우, 일반속성이 주식별자의 일부에만 종속될수있다

* 제3정규형
주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다

* 주의사항
정규화는 성능상 이롭지만 지나친 정규화는 성능저하를 일으킨다.
ex. 회원의 배송상태를 조회하려면 여러번의 JOIN을 해야하는데 이럴때는 반정규화룰 통해 성능을 개선한다.

-------
* 반정규화
데이터 조회성능을 향상시키기 위해 데이터의 중복을 허용/데이터를 그룹핑하는 과정
조회성능은 향상될 수 있으나 입력, 수정, 삭제 성능은 저하될 수 있음
데이터 정합성으로 이슈가 발생할 수 있다
정규화가 끝난 후 거치게 되는 과정이며 정규화와 마찬가지 일정한 룰이 존재함.

'반정규화'는 모든 정규화를 마친후 성능상 이슈가 있을 떄에만 고려
정규화를 했을 때 조회성능이 심각하게 저하되는 경우 반정규화를 고려
'반정규화'를 하면 데이터 무결성이 저해된다고 볼수있음
'정규화'를 하면 입력, 수정, 삭제 성능이 향상됨

---
테이블 반정규화 :

* 테이블 병합 : 1:1 관계, 1:M관계, 슈퍼 서브타입 테이블 병합
업무 프로세스상 JOIN이 필요한 경우가 많아 테이블통합이 성능측면에서 유리할 경우 고려
1:M관계 테이블 병합의 경우 1쪽에 해당하는 엔터티의 속성 개수가 많으면 병합했을경우 중복 데이터가 많아지므로 테이블 병합에 적절치못함

* 테이블 분할 : 테이블 수직분할(속성분할) 			: 엔터티의 일부 속성을 별도의 엔터티로 분할(1:1관계 성립)
		 테이블 수평분할(인스턴스분할,파티셔닝)	: 엔터티의 인스턴스를 특정 기준으로 별도의 엔터티로 분할(파티셔닝)

-수직분할 시 
테이블의 일부 속성을 별도의 테이블로 분리하는것이다
한개의 블록에 더 많은 인스턴스를 저장할 수 있게된다
1:1관계의 테이블이 두개 생기는것이다 // 1:M관계가 형성되는것이 아니다 
속성의 사용 빈도나 속성값의 NULL여부를 기준으로 분할 할 수 있다.

-수평분할 시
테이블의 특정 인스턴스를 별도의 테이블로 분할하는것이다
데이터베이스의 파티셔닝 기법을 주로 이용한다
관계가 없는 다수의 테이블이 생성된다
기분은 기간이지만 다른 속성이 될 수도 있다

* 테이블 추가 : 중복, 통계, 이력, 부분 테이블 추가
중복 테이블 추가의 경우 데이터의 중복을 감안하더라도 반드시 필요하다고 판단되는 경우를 별도의 엔터티를 추가함.


중복 테이블을 추가하는 경우 : 
단순히 같은 데이터를 여러테이블에 저장하는것은 정합성에 위배되는 상황이니 절대금물
특정 범위의 많은 데이터를 자주 처리해야하는 경우
정규화로 인한 성능 감소가 발생한 경우
미리 계산된 값을 저장해 둠으로써 어플리케이션 성능을 향상시키려는 경우

-------
* 컬럼 반정규화

중복컬럼 추가 		: JOIN이 필요한 경우가 많아 컬럼을 추가하는것이 성능측면 유리할 경우 고려
파생컬럼 추가		: 부하가 염려되는 계산값을 미리 컬럼으로 추가하여 보관하는 방식/상품의 재고나 프로모션 적용 할인가 등이 이에 해당.
이력 테이블컬럼 추가	: 대량 이력테이블 조회할때 속도 느려짐을 대비해 조회기준이 될것으로 판단되는 컬럼을 미리추가하는 방식/최신데이터 여부 등이 이에 해당.

* 관계 반정규화 : JOIN이 필요한 경우가 많아 컬럼을 추가하는것이 성능측면 유리할 경우 고려

*****컬럼 반정규화와 관계 반정규화를 잘 나눠서 외울것*****

-------
* 트랜잭션 : 	데이터조작위한 논리적인 작업단위
	 	트랜잭션은 하나의 커밋 단위로 묶어야 한다
		데이터 모델로 표현할 수 있으며 데이터는 트랜잭션 범위로 묶일 수 있다.

* NULL : 존재하지않음, 값이없음

---
데이터 모델링의 순서 :
	
	데이터 모델에 맞게 정규화를 수행한다
	데이터베이스의 용량 및 트랜젝션 유형을 파악하여 성능 저하를 일으키는 부분이 없는지 검토
	용량과 트랜잭션 유형에 맞게 반정규화를 수행
	성능 향상을 위한 이력모델의 조정, PK/FK 조정, 슈퍼/서브타입 조정등을 수행
	데이터 모델의 성능을 검증

---
삽입이상 : 기본적으로 주문되지않은 상품의 정보를 삽입할 수 없으며 강제로 삽입하기 위해서는 존재하지 않는 가짜주문번호를 만들어주어야함
갱신이상 : 중복된 데이터중 일부만 업데이트 되어 데이터의 불일치가 발생하게 되는 현상
삭제이상 : 데이터 삭제시 삭제되면 안 되는 데이터까지 덩달아 삭제되는 현상

























